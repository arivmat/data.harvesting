# Libraries
```{r}

packages = c("RSelenium", "rvest", "magrittr", "tidyr", "dplyr", "magick",
             "scales", "tidyverse", "ggplot2", "scales", "shiny", "writexl")

package.check <- lapply(packages,
                        FUN = function(x){
                          if (!require(x,character.only = TRUE)){
                            install.packages(x,dependencies = TRUE)
                            library(x, character.only = TRUE)
                          }
                        }
)

```


#Selenium
```{r}

remDr <- remoteDriver(port = 4449)
remDr$open()

```

## Scrapping - Casa Libro

```{r}


# Navegar a una página para comprobar que funciona
remDr$navigate("https://www.casadellibro.com")

# Intenta encontrar el botón de rechazar, si no lo encuentra, no hace nada
tryCatch({
  # Intenta encontrar el botón de rechazar en la ventana de privacidad
  rechazar <- remDr$findElement(using = "xpath", "//button[@id='onetrust-reject-all-handler']")
  
  # Si el botón se encuentra, hacer clic en él
  rechazar$clickElement()
}, error = function(e) {
  # Si ocurre un error (por ejemplo, si no se encuentra el elemento), no hacer nada
  message("No se encontró la ventana de privacidad o el botón de rechazar")
})


Sys.sleep(5)

# Categories & Subcategories
categories <- data.frame(
  category = c("Biography", "Science Fiction", "Mystery & Thriller", "Romance", "Young Adult Fantasy"),
  category_xpath = c("//a[contains(text(),'No Ficción')]",
                     "//a[contains(text(),'Ficción')]", 
                     "//a[contains(text(),'Ficción')]", 
                     "//a[contains(text(),'Ficción')]", 
                     "//a[contains(text(),'Juvenil')]"),
  subcategory_xpath = c("//a[contains(text(),'Biografías')]",
                        "//a[span[contains(text(),'Novela de ciencia ficción')]]", 
                        "//a[span[contains(text(),'Novela negra')]]", 
                        "//a[span[contains(text(),'Novela romántica y erótica')]]",
                        "//a[span[contains(text(),'Fantasía')]]")
)

# Función de scrapbooks (como la que ya tienes)
scrap_books <- function(category_xpath, subcategory_xpath, category_name, num_pages = 10) {
  
  # Hacer clic en la categoría
  enlace <- remDr$findElement(using = "xpath", category_xpath)
  enlace$clickElement()
  
  # Hacer clic en la subcategoría
  Sys.sleep(5)  # Esperar a que la página cargue
  enlace <- remDr$findElement(using = "xpath", subcategory_xpath)
  enlace$clickElement()
  
  # Crear listas vacías para almacenar los datos
  all_titles <- c()
  all_authors <- c()
  all_img_urls <- c()

  # Extraer datos de las primeras n páginas
  for (i in 1:num_pages) {
    
    Sys.sleep(5)  # Espera para que la página cargue
    
    # Extraer los elementos de productos
    product_elems <- remDr$findElements(using = "css selector", "div.compact-product")
    product_html <- sapply(product_elems, function(x) x$getElementAttribute("outerHTML")[[1]])
    parsed_products <- lapply(product_html, read_html)
    
    # Extraer Títulos
    titles <- sapply(parsed_products, function(x) x %>% html_node("a.product-title") %>% html_text())
    
    # Extraer Autores
    authors <- sapply(parsed_products, function(x) {
      author_node <- x %>% html_node("p.truncate-text")
      if (!is.null(author_node)) html_text(author_node) else NA
    })
    
    # Extraer URLs de las imágenes
    img_urls <- sapply(parsed_products, function(x) {
      x %>% html_node("img") %>% html_attr("src")
    })
    
    # Guardar en listas
    all_titles <- c(all_titles, titles)
    all_authors <- c(all_authors, authors)
    all_img_urls <- c(all_img_urls, img_urls)
    
    # Pasar a la siguiente página
    boton_pagina <- tryCatch({
      remDr$findElement(using = "xpath", paste0("//button[normalize-space(text())='", i + 1, "']"))
    }, error = function(e) NULL)
    
    if (!is.null(boton_pagina)) {
      boton_pagina$clickElement()
      Sys.sleep(5)  # Esperar a que cargue la nueva página
      remDr$refresh()  # Refrescar el DOM
    } else {
      message("Botón de página ", i + 1, " no encontrado.")
      break
    }
  }
  
  # Crear dataframe con los datos
  result <- data.frame(
    category = category_name,
    title = all_titles,
    author = all_authors,
    img_url = all_img_urls,
    stringsAsFactors = FALSE
  )
  
  return(result)
}


# Iterar sobre las categorías y scrapear cada una
temp_casa.libro <- list()

for (i in 1:nrow(categories)) {
  books <- scrap_books(
    category_xpath = categories$category_xpath[i],
    subcategory_xpath = categories$subcategory_xpath[i],
    category_name = categories$category[i]
  )
  
  temp_casa.libro[[categories$category[i]]] <- temp_CL
}

# Guardar resultados 
casa.libro <- do.call(rbind, temp_casa.libro)

```
## End selenium

```{r}
# Finalizar Selenium
remDr$close()

```


#Extract colors

```{r}

# Modificar la función extract_colors para adaptarse a un dataframe
extract_colors <- function(image_url, n_colors = 6) {
  # Leer la imagen desde la URL
  img <- image_read(image_url) %>%
    image_resize("50x50") # Redimensionar para reducir el tiempo de procesamiento
  
  # Convertir la imagen a datos de píxeles
  img_data <- image_data(img)
  
  # Verificar si la estructura de img_data es un bitmap
  if (inherits(img_data, "bitmap")) {
    # Si es un bitmap, lo convertimos a un formato numérico
    img_data <- as.integer(img_data) / 255
  }
  
  # Convertir la imagen a una data.frame
  # Extraemos los canales RGB
  df <- data.frame(
    red = as.vector(img_data[,,1]),    # Canal rojo
    green = as.vector(img_data[,,2]),  # Canal verde
    blue = as.vector(img_data[,,3])    # Canal azul
  )
  
  # Aplicar k-means para encontrar los colores dominantes
  kmeans_result <- kmeans(df, centers = n_colors, nstart = 25, iter.max = 100)
  
  # Convertir los colores dominantes a formato RGB
  dominant_colors <- rgb(kmeans_result$centers[,1],
                         kmeans_result$centers[,2],
                         kmeans_result$centers[,3], maxColorValue = 1)
  
  # Devolver los colores como un vector de colores (no como lista)
  return(dominant_colors)
}

# Aplicar la función a cada imagen en el dataframe, devolviendo una lista de colores por imagen
casa.libro$colors <- sapply(casa.libro$img_url, extract_colors, simplify = FALSE)

# Mostrar los colores del ID 1
show_col(casa.libro$colors[[1]])

```



# Goodreads

```{r}
# Definir las URL
url <- "https://www.goodreads.com/choiceawards/readers-favorite-mystery-thriller-books-2024"
url2 <- "https://www.goodreads.com/choiceawards/readers-favorite-romance-books-2024"
url3 <- "https://www.goodreads.com/choiceawards/readers-favorite-ya-fantasy-books-2024"
url4 <- "https://www.goodreads.com/choiceawards/readers-favorite-science-fiction-books-2024"
url5 <- "https://www.goodreads.com/choiceawards/readers-favorite-history-bio-books-2024"
urls <- c(url, url2, url3, url4, url5)

goodreads <- data.frame()

## Loop para extraer de cada link titulo, imagen y categoria
for (url in urls) {
    page <- read_html(url)
    
    # Extract book titles
    titles <- page %>%
        html_nodes(".pollAnswer__bookLink img") %>% 
        html_attr("alt")
    
    # Extract cover images
    covers <- page %>%
        html_nodes(".pollAnswer__bookLink img") %>% 
        html_attr("src")
    
    # Extract category from the HTML
    category <- page %>%
        html_element(".gcaMastheader") %>%  
        html_text() %>%  
        gsub("Readers' Favorite ", "", .) 
    
    # Create a temporary data frame
    temp_books <- data.frame(title = titles, img_url = covers, category = category, stringsAsFactors = FALSE)
    
    # Append to the main data frame
    goodreads <- bind_rows(goodreads, temp_books)
}

# Separar titulo y autor con general expressions
goodreads <- goodreads %>%
  rowwise() %>%
  mutate(colors = list(extract_colors(img_url)))  %>%
    mutate(
        author = str_extract(title, "(?<= by ).*"),
        title = str_extract(title, ".*(?= by )"))

# Gráfico del primeros libros
show_col(goodreads$colors[[1]])

```
# Unificar bbdd

```{r}

best_books <- bind_rows(
  goodreads |> 
    mutate(webpage = "Goodreads", category = recode(category, "History & Biography" = "Biography")),
  casa.libro |> 
    mutate(webpage = "Casa del libro")
  ) |> 
  select(category, title, author, colors, webpage)

write_xlsx(best_books, "best_books.xlsx")
```


# Análsis

## Tidy data

```{r}
# Expand the dataset to individual rows for each color
best_books_expanded <- best_books %>%
  unnest(colors)
```

## Hex to RGB

```{r}
# Function to convert hex colors to RGB
hex_to_rgb <- function(hex) {
  rgb_matrix <- col2rgb(hex) / 255  
  data.frame(hex = hex, R = rgb_matrix[1, ], G = rgb_matrix[2, ], B = rgb_matrix[3, ])
}

# Convert colors from hex to RGB
color_data <- best_books_expanded %>%
  mutate(rgb_values = map(colors, hex_to_rgb)) %>%
  unnest(rgb_values) 
```

## Clusters

```{r}
# Apply k-means clustering to group colors into 6 clusters
set.seed(123)  # For reproducibility

color_data_clustered <- color_data %>%
  group_by(category) %>%
  group_modify(~ {
    if (nrow(.x) < 6) {
      .x$cluster <- as.factor(seq_len(nrow(.x)))  # Asigna clusters únicos si hay menos de 6 filas
    } else {
      kmeans_result <- kmeans(.x[, c("R", "G", "B")], centers = 6)
      .x$cluster <- as.factor(kmeans_result$cluster)
    }
    return(.x)
  }) %>%
  ungroup()

# # Assign clustered colors back to dataset --> NO ES NECESARIO YA QUE LO TENEMOS EN COLOR_DATA_CLUSTERED
# color_data$cluster <- as.factor(kmeans_result$cluster[match(color_data$hex, unique(color_data$hex))])

```


### Cluster representative

```{r}
# Map clusters to representative colors (choosing the most frequent color in each)
cluster_representative <- color_data_clustered %>%
  group_by(category, cluster) %>%
  summarise(representative_color = first(hex))  # Pick first as representative
```


### Map clusters

```{r}
# Replace original colors with their cluster representative
best_books_clustered <- best_books_expanded %>%
  left_join(color_data_clustered, by = "colors") %>%
  left_join(cluster_representative, by = "cluster") %>%
  select(category, representative_color)

```


## Colors/category

```{r}
# Count occurrences of grouped colors per category
color_counts <- best_books_clustered %>%
  group_by(category, representative_color) %>%
  summarise(Freq = n(), .groups = "drop") %>%
  arrange(category, desc(Freq))

```

### Top 6 per category

```{r}
# Extract top 6 colors per category and add a position for tiles
top_colors_all <- color_counts %>%
  group_by(category) %>%
  arrange(desc(Freq)) %>%
  slice_head(n = 6) %>%
  mutate(position = row_number()) %>%  # Create positions (1 to 6) to graph
  ungroup()
```

### Plot 

```{r}
ggplot(top_colors_all, aes(x = position, y = category, fill = representative_color)) +
    geom_tile(color = "white", linewidth = 0.5) + 
    geom_text(aes(label = representative_color), color = "white", size = 4, fontface = "bold") +  
    scale_fill_identity() +  
    theme_minimal() +
    labs(title = "Top 6 Most Frequent Colors by Category", x = NULL, y = NULL) +
    theme(
        axis.text.x = element_blank(),  
        axis.ticks = element_blank(),
        panel.grid = element_blank(),
        strip.text = element_text(face = "bold", size = 12), 
        axis.text.y = element_text(face = "bold", size = 10)  
    )


```

## Colors/category/web

```{r}

cluster_representative <- color_data_clustered %>%
  group_by(category, cluster, webpage) %>%
  summarise(representative_color = first(hex))  # Pick first as representative

# Replace original colors with their cluster representative
best_books_clustered <- best_books_expanded %>%
  left_join(color_data_clustered, by = "colors") %>%
  left_join(cluster_representative, by = "cluster") %>%
  select(category, representative_color, webpage)

# Count occurrences of grouped colors per category
color_counts <- best_books_clustered %>%
  group_by(category, representative_color, webpage) %>%
  summarise(Freq = n(), .groups = "drop") %>%
  arrange(category, desc(Freq))

# Extract top 6 colors per category and add a position for tiles
top_colors_all <- color_counts %>%
  group_by(category, webpage) %>%
  arrange(desc(Freq)) %>%
  slice_head(n = 6) %>%
  mutate(position = row_number()) %>%  # Create positions (1 to 6)
  ungroup()

# Create a tile plot with six colors per category
ggplot(top_colors_all, aes(x = position, y = category, fill = representative_color)) +
    geom_tile(color = "white", size = 0.5) +  # White border for separation
    geom_text(aes(label = representative_color), color = "white", size = 4, fontface = "bold") +  # Add color labels
    scale_fill_identity() +  # Use actual colors
    theme_minimal() +
    labs(title = "Top 6 Most Frequent Colors by Category and Source", x = NULL, y = NULL) +
    theme(
        axis.text.x = element_blank(),  # Hide x-axis labels
        axis.ticks = element_blank(),
        panel.grid = element_blank(),
        strip.text = element_text(face = "bold", size = 12),  # Style category labels
        axis.text.y = element_text(face = "bold", size = 10)  # Keep category names visible
    ) +
    facet_wrap(~webpage)  # Separate by source (Goodreads, Casa del Libro)


```
  
# Shiny?

```{r}
library(shiny)
library(dplyr)
library(ggplot2)
library(tidyr)
library(stringr)

# Datos procesados (asegúrate de que `best_books_expanded` esté listo y tenga las columnas necesarias)

# UI
ui <- fluidPage(
  titlePanel("Colores Predominantes de Libros"),
  
  # Agregamos algo de CSS para mejorar el diseño
  tags$style(HTML("
    .filters-container {
      margin-bottom: 20px;
      padding: 10px;
      border: 1px solid #ddd;
      background-color: #f9f9f9;
      border-radius: 5px;
    }
    .color-rectangle {
      height: 25px;
      flex: 1 1 8.33%;  /* Ajustado a 8.33% para 12 rectángulos por fila */
      margin: 5px;
    }
    .color-boxes {
      display: flex;
      flex-wrap: wrap;  /* Permite que los rectángulos se acomoden en filas */
      justify-content: flex-start;  /* Alineación al inicio de la fila */
    }
  ")),
  
  # Estructura para los filtros
  fluidRow(
    column(12,
           div(class = "filters-container",
               # Filtro por categoría con opción "Todo"
               selectInput("category_select", "Selecciona una categoría:",
                           choices = c("Todo", unique(best_books_expanded$category)),
                           selected = "Todo"),
               
               # Filtro por webpage (opcional)
               selectInput("webpage_select", "Selecciona un webpage (opcional):",
                           choices = c("Todos", unique(best_books_expanded$webpage)),
                           selected = "Todos"),
               
               # Opción para elegir si se ven los colores predominantes
               checkboxInput("show_predominant", "Mostrar solo colores predominantes", value = FALSE)
           )
    )
  ),
  
  # Contenedor principal de los colores
  mainPanel(
    tabsetPanel(
      tabPanel("Colores",
               fluidRow(
                 # Mostrar los colores filtrados en rectángulos
                 uiOutput("color_display")
               )
      ),
      tabPanel("Colores Predominantes",
               plotOutput("color_plot")
      )
    )
  )
)

# Servidor
server <- function(input, output, session) {
  
  # Filtrar datos por categoría (y por webpage si se selecciona)
  filtered_data <- reactive({
    req(input$category_select)
    
    # Si se selecciona "Todo", no filtramos por categoría
    data <- best_books_expanded
    if (input$category_select != "Todo") {
      # Filtrar por categoría seleccionada
      data <- data %>%
        filter(category == input$category_select)
    }
    
    # Si selecciona un webpage específico, filtrar también por ese
    if (input$webpage_select != "Todos") {
      data <- data %>% filter(webpage == input$webpage_select)
    }
    
    if (input$show_predominant) {
      # Si se selecciona mostrar colores predominantes, filtrar por colores predominantes
      data <- data %>%
        group_by(category, colors) %>%
        summarise(Freq = n(), .groups = "drop") %>%
        arrange(desc(Freq))
    }
    
    return(data)
  })
  
  # Mostrar colores en forma de rectángulos
  output$color_display <- renderUI({
    data <- filtered_data()
    
    # Si no hay datos después del filtro
    if (nrow(data) == 0) {
      return(NULL)
    }
    
    # Crear un rectángulo por cada color
    color_elements <- lapply(1:nrow(data), function(i) {
      tags$div(
        class = "color-rectangle",
        style = paste("background-color:", data$colors[i], ";")
      )
    })
    
    # Devolver todos los rectángulos
    tags$div(class = "color-boxes", do.call(tagList, color_elements))
  })
  
  # Mostrar gráfico de colores predominantes
  output$color_plot <- renderPlot({
    data <- filtered_data()
    
    # Si no hay datos después del filtro
    if (nrow(data) == 0) {
      return(NULL)
    }
    
    # Crear un gráfico de barras para los colores predominantes
    ggplot(data, aes(x = colors, fill = colors)) +
      geom_bar() +
      scale_fill_identity() +  # Mostrar colores reales
      labs(title = "Colores Predominantes",
           x = "Color", y = "Frecuencia") +
      theme_minimal() +
      theme(axis.text.x = element_text(angle = 45, hjust = 1))
  })
}

# Ejecutar la app
shinyApp(ui = ui, server = server)

```





